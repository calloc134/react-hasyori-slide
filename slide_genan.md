---
marp: true
---

# 端折りまくって学ぶ React の内部

---

<!-- (三分間なのでかなり端折る) -->

## ざっくりとした React の構造

<!-- (ここに、優先度付きキューや Fiber ツリーの構造を図示 -->
<!-- Fiber ツリーについては、current と workInProgress の二つのツリーが存在することを明示) -->

---

## React のレンダリングの流れ

- トリガーフェーズ
  - レンダリングを発動
- スケジューリングフェーズ
  - タスクをいいタイミングで実行
- レンダーフェーズ
  - 仮想 DOM を作成して差分検知
- コミットフェーズ
  - 実 DOM に書き込み

---

## トリガーフェーズ

render 関数や useState のディスパッチを呼び出すことで、React のレンダリングがトリガーされる

<!-- (ここはかなり端折る -->
<!-- update オブジェクトの話もしない) -->

---

## スケジューリングフェーズ

react のスケジューリングでは、タスクをバイナリヒープで管理する
優先度によってタスクを並び替え、優先度の高いものから実行していく

---

### react のスケジューリングについて

<!-- 独自のスケジューラ react-scheduler を利用している
それぞれのタスクについて期限が設定されており、Concurrent Mode では適宜中断するべきかを判断する関数を呼び出し、必要であればタスクを中断するような仕組みがある
この仕組みは Python の asyncio のような協調的スケジューリングに近い -->

<!-- (ここも「協調的スケジューリングにより中断可能です」とだけ言及して端折る) -->

---

### 優先度付きキューとは？

<!-- (余談として扱う)

(優先度付きキューの詳細について解説。React の Scheduler パッケージのタスクキューで利用されている)

(橋折ポイント: 実際はタスクキューとタイマーキューの 2 つが存在するが、今回はタスクキューのみ解説) -->

---

### レーンとは？

<!-- (レーンの詳細について解説。ビットマスクで表現されて優先度を表現するということ) -->

## レンダーフェーズ

(端折りポイント
ステートやフックの詳細は今回端折ってしまって良い)

Fiber ノードとツリーの仕組み

いわゆる仮想 DOM とよく呼ばれるもので、根本のノードから二種類のツリーが生える
(ダブルバッファリング)

根本のノード →FiberRootNode
FiberRootNode から二つのツリーが生える
current → 現在のツリー
workInProgress → 現在レンダリング中の新しいツリー

### Fiber ノード詳細

今回解説する主要な Fiber ノードの種類は以下の通り

- FunctionComponent
  - 関数コンポーネント
  - 私達が普段書いているコンポーネント
- HostComponent
  - DOM ノード
  - web であれば<div> や <span>、<p> といった HTML タグ

Fiber ノードにおける他ノード参照は以下の通り

- child: 子ノード
- sibling: 兄弟ノード
- return: 親ノード

これを利用することでノードを巡回できる

Fiber ノードのプロパティは以下の通り
(ここに fiber ノードのプロパティ記述)

- type/tag: ノードの種類
- flags: ノードのフラグ
  - 行うべき変更などが保持される
- stateNode: ノードの状態
  - 生成された DOM インスタンスなど
  - 関数コンポーネントの場合は実体がないため null

### レンダー開始

<!-- early bailoutは省略 -->

コンポーネント の種類(tag)によって分岐

#### 関数コンポーネントを実行 A

<!-- (beginWorkのreconcile前部分、関数コンポーネントはここが処理必要になる) -->

レンダリングが必要なので実行
renderWithHooks を使ってフックを使いながら関数コンポーネント実行
ここで私達の書いてるコンポーネントが動作する
返された ReactNode を保持

### 差分検出 B

<!-- (beginWorkのreconcile部分、差分検出の処理) -->

子ノードについてリストを比較し、Fiber ノードに差があるかを検出

- 同じタイプの要素は再利用
- key があれば key で一致をとり差分比較
- key がなければインデックスで一致をとり差分比較

その結果に応じて flags にフラグを設定

- Placement: 新しいノードを追加する
- Update: 既存のノードを更新する
- Deletion: 既存のノードを削除する

実はフラグは二進数で、マージが可能

### 後処理 C

<!-- (beginWorkのcompleteWork部分、後処理の処理) -->

主に以下のような処理をする

先程設定したフラグを元に親ノードに OR でフラグをマージしていく

- 最終的に root ノードまでフラグがマージされる

もし HostComponent であれば、DOM ノードを生成して stateNode に保持

- ここで実際の DOM ノードが生成される
- 生成された DOM ノードは、stateNode に保持される

この処理の繰り返しが行われる
巡回の順番は以下の通り

1. まず対象ノードに対して A、B を実行
2. 子供がいるか調査 子供がいれば対象ノードを子供に変更して →1
3. 兄弟がいれば調査 兄弟がいれば対象ノードを兄弟に変更して →1
4. 兄弟がいなければ親ノードに戻り、再度兄弟がいるか調査 →3
5. 戻る親ノードがなくなったら終了

## コミットフェーズ

フラグや stateNode を元に、実際の DOM ノードに変更を加える

すべて処理が終わったとき、current と workInProgress の二つのツリーを交換する
(この時、current は古いツリーに、WIP は新しいツリーに)
そして WIP は次のレンダリングで、使えるリソースは再利用されながらまた新しく作成されることとなる
(リソース作成の手間が省けてエコ)
